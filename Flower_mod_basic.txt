
model{

# -------------------------------------------------
# States (S):
# 1 empty
# 2 low state
# 3 high state
# 
# Observations (O):  
# 1 not observed
# 2 observed low state
# 3 observed high state
# -------------------------------------------------

#### PRIORS ####
  
  #detection parameters
  
  rho.l ~ dbeta(pl.a,pl.b) #base detection for low state
  rho.h ~ dbeta(ph.a,ph.b) #base detection for high state

  delta ~ dbeta(delta.a, delta.b) #probability of observing the high state given species has been detected and true state is high

  pmulti.l <-  rho.l
  pmulti.h <-  rho.h
  
  #state parameters
  
  for (i in 1:n.sites){  
    omega[i] ~ dbeta(omega.a[i], omega.b[i]) #probability of being invaded regardless of state
    phi[i] ~ dbeta(phi.a[i], phi.b[i]) #conditional probability that FR is high abundance given present
    
    ps[1,i] <- 1-omega[i] #probability of not invaded
    ps[2,i] <- omega[i]*(1-phi[i]) #probability of invaded at low abundance
    ps[3,i] <- omega[i]*phi[i] #probability of invaded at high abundance
  
    
  #--------------------------------------------------#
  # OBSERVATION PROBABILITIES 
    # Observation probabilities of given S(t)
    #index = [current state, location, current observation]
   
    #Empty and not observed    
    po.multi[1,i,1] <- 1
    
    #Empty and observed low 
    po.multi[1,i,2] <- 0
    
    #Empty and observed high  
    po.multi[1,i,3] <- 0
 
    #Low state and not observed   
    po.multi[2,i,1] <- 1-pmulti.l #not detected probability
    
    #Low state and observed low 
    po.multi[2,i,2] <- pmulti.l #detection probability
      
    #Low state and observed high 
    po.multi[2,i,3] <- 0 
      
    #High state and not observed   
    po.multi[3,i,1] <- 1-pmulti.h #not detected probability
      
    #High state and observed low 
    po.multi[3,i,2] <- (1-pmulti.h)*(1-delta) #detection probability
      
    #high abundance observed high abundance
    po.multi[3,i,3] <- pmulti.h*delta


  #### LIKELIHOOD ####
    State[i] ~ dcat(ps[,i])
  
    y.multi[i] ~ dcat(po.multi[State[i], i, ])
  
    #Derived parmeter
    State.fin[i] <- State[i] 
   
} #i
  
} #end model

